# ============================================================================
# CMakeLists.txt
# ============================================================================
cmake_minimum_required(VERSION 3.16)
project(MusicPlayer VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# 设置 UTF-8 编码
if(MSVC)
    add_compile_options(/utf-8)
elseif(MINGW)
    add_compile_options(-finput-charset=UTF-8 -fexec-charset=UTF-8)
endif()

# 在这里添加 Core5Compat 模块
find_package(Qt6 REQUIRED COMPONENTS Core Widgets Multimedia Core5Compat)

add_executable(MusicPlayer
    main.cpp
    mainwindow.cpp
    mainwindow.h
    playlist.cpp
    playlist.h
    playlistmanager.cpp
    playlistmanager.h
)

# 在这里链接 Qt6::Core5Compat 库
target_link_libraries(MusicPlayer
    Qt6::Core
    Qt6::Widgets
    Qt6::Multimedia
    Qt6::Core5Compat
)

# Windows 平台设置
if(WIN32)
    set_target_properties(MusicPlayer PROPERTIES
        WIN32_EXECUTABLE TRUE
    )
endif()
# ============================================================================
// playlist.h - 播放列表类
// ============================================================================
#ifndef PLAYLIST_H
#define PLAYLIST_H

#include <QString>
#include <QList>
#include <QUrl>

struct Song {
    QString title;
    QString artist;
    QString filePath;
    qint64 duration;  // 毫秒
    
    Song(const QString& path = "") 
        : filePath(path), duration(0), artist("未知艺术家") {
        // 从文件路径提取歌曲名（使用正确的分隔符）
        QStringList parts = path.split(QRegularExpression("[/\\\\]"));
        if (!parts.isEmpty()) {
            title = parts.last();
            title.replace(QRegularExpression("\\.(mp3|wav|ogg|flac|m4a)$", 
                         QRegularExpression::CaseInsensitiveOption), "");
        }
    }
};

class Playlist {
public:
    explicit Playlist(const QString& name = "新建列表");
    
    QString getName() const { return m_name; }
    void setName(const QString& name) { m_name = name; }
    
    int songCount() const { return m_songs.size(); }
    const QList<Song>& getSongs() const { return m_songs; }
    Song getSong(int index) const;
    
    void addSong(const Song& song);
    void addSongs(const QList<Song>& songs);
    void removeSong(int index);
    void clear();
    
private:
    QString m_name;
    QList<Song> m_songs;
};

#endif // PLAYLIST_H

// ============================================================================
// playlist.cpp
// ============================================================================
#include "playlist.h"
#include <QFileInfo>

Playlist::Playlist(const QString& name) : m_name(name) {}

Song Playlist::getSong(int index) const {
    if (index >= 0 && index < m_songs.size()) {
        return m_songs[index];
    }
    return Song();
}

void Playlist::addSong(const Song& song) {
    m_songs.append(song);
}

void Playlist::addSongs(const QList<Song>& songs) {
    m_songs.append(songs);
}

void Playlist::removeSong(int index) {
    if (index >= 0 && index < m_songs.size()) {
        m_songs.removeAt(index);
    }
}

void Playlist::clear() {
    m_songs.clear();
}

// ============================================================================
// playlistmanager.h - 播放列表管理器
// ============================================================================
#ifndef PLAYLISTMANAGER_H
#define PLAYLISTMANAGER_H

#include <QObject>
#include <QList>
#include "playlist.h"

class PlaylistManager : public QObject {
    Q_OBJECT
    
public:
    explicit PlaylistManager(QObject* parent = nullptr);
    
    int playlistCount() const { return m_playlists.size(); }
    Playlist* getPlaylist(int index);
    const QList<Playlist*>& getPlaylists() const { return m_playlists; }
    
    void addPlaylist(const QString& name);
    void removePlaylist(int index);
    
signals:
    void playlistAdded(int index);
    void playlistRemoved(int index);
    
private:
    QList<Playlist*> m_playlists;
};

#endif // PLAYLISTMANAGER_H

// ============================================================================
// playlistmanager.cpp
// ============================================================================
#include "playlistmanager.h"

PlaylistManager::PlaylistManager(QObject* parent) : QObject(parent) {
    // 创建默认播放列表
    m_playlists.append(new Playlist("我喜欢"));
}

Playlist* PlaylistManager::getPlaylist(int index) {
    if (index >= 0 && index < m_playlists.size()) {
        return m_playlists[index];
    }
    return nullptr;
}

void PlaylistManager::addPlaylist(const QString& name) {
    m_playlists.append(new Playlist(name));
    emit playlistAdded(m_playlists.size() - 1);
}

void PlaylistManager::removePlaylist(int index) {
    if (index >= 0 && index < m_playlists.size() && m_playlists.size() > 1) {
        delete m_playlists[index];
        m_playlists.removeAt(index);
        emit playlistRemoved(index);
    }
}

// ============================================================================
// mainwindow.h - 主窗口
// ============================================================================
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QMediaPlayer>
#include <QAudioOutput>
#include <QPushButton>
#include <QSlider>
#include <QLabel>
#include <QListWidget>
#include <QComboBox>
#include <QMouseEvent>
#include "playlistmanager.h"

// 自定义 Slider 类，支持点击跳转
class ClickableSlider : public QSlider {
    Q_OBJECT
public:
    explicit ClickableSlider(Qt::Orientation orientation, QWidget* parent = nullptr)
        : QSlider(orientation, parent) {}

protected:
    void mousePressEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton) {
            int value;
            if (orientation() == Qt::Horizontal) {
                double pos = event->position().x() / (double)width();
                value = pos * (maximum() - minimum()) + minimum();
            } else {
                double pos = event->position().y() / (double)height();
                value = pos * (maximum() - minimum()) + minimum();
            }
            setValue(value);
            emit sliderMoved(value);
            emit sliderPressed();
        }
        QSlider::mousePressEvent(event);
    }
};

class MainWindow : public QMainWindow {
    Q_OBJECT
    
public:
    explicit MainWindow(QWidget* parent = nullptr);
    ~MainWindow();
    
private slots:
    void onPlayPauseClicked();
    void onPreviousClicked();
    void onNextClicked();
    void onAddSongsClicked();
    void onCreatePlaylistClicked();
    void onDeletePlaylistClicked();
    void onPlaylistChanged(int index);
    void onSongDoubleClicked(QListWidgetItem* item);
    
    void onPositionChanged(qint64 position);
    void onDurationChanged(qint64 duration);
    void onProgressSliderMoved(int position);
    void onVolumeChanged(int value);
    void onMediaStatusChanged(QMediaPlayer::MediaStatus status);
    
private:
    void setupUI();
    void updatePlaylistView();
    void updateSongListView();
    void playSong(int index);
    void updatePlayPauseButton();
    QString formatTime(qint64 milliseconds);
    
    // UI 组件
    QWidget* m_centralWidget;
    QPushButton* m_playPauseBtn;
    QPushButton* m_previousBtn;
    QPushButton* m_nextBtn;
    QPushButton* m_addSongsBtn;
    QPushButton* m_createPlaylistBtn;
    QPushButton* m_deletePlaylistBtn;
    
    ClickableSlider* m_progressSlider;
    ClickableSlider* m_volumeSlider;
    QLabel* m_currentTimeLabel;
    QLabel* m_totalTimeLabel;
    QLabel* m_songTitleLabel;
    QLabel* m_songArtistLabel;
    
    QComboBox* m_playlistComboBox;
    QListWidget* m_songListWidget;
    
    // 播放器
    QMediaPlayer* m_player;
    QAudioOutput* m_audioOutput;
    PlaylistManager* m_playlistManager;
    
    int m_currentPlaylistIndex;
    int m_currentSongIndex;
};

#endif // MAINWINDOW_H

// ============================================================================
// mainwindow.cpp - 主窗口实现
// ============================================================================
#include "mainwindow.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFileDialog>
#include <QInputDialog>
#include <QMessageBox>
#include <QGroupBox>
#include <QStyle>

MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
    , m_currentPlaylistIndex(0)
    , m_currentSongIndex(-1)
{
    m_player = new QMediaPlayer(this);
    m_audioOutput = new QAudioOutput(this);
    m_player->setAudioOutput(m_audioOutput);
    
    m_playlistManager = new PlaylistManager(this);
    
    setupUI();
    
    // 连接播放器信号
    connect(m_player, &QMediaPlayer::positionChanged, 
            this, &MainWindow::onPositionChanged);
    connect(m_player, &QMediaPlayer::durationChanged, 
            this, &MainWindow::onDurationChanged);
    connect(m_player, &QMediaPlayer::mediaStatusChanged,
            this, &MainWindow::onMediaStatusChanged);
    
    updatePlaylistView();
    updateSongListView();
}

MainWindow::~MainWindow() {}

void MainWindow::setupUI() {
    setWindowTitle("千千静听 - Qt6 音乐播放器");
    setMinimumSize(900, 600);
    
    m_centralWidget = new QWidget(this);
    setCentralWidget(m_centralWidget);
    
    QVBoxLayout* mainLayout = new QVBoxLayout(m_centralWidget);
    
    // 顶部：当前播放信息
    QGroupBox* infoGroup = new QGroupBox("正在播放", this);
    QVBoxLayout* infoLayout = new QVBoxLayout(infoGroup);
    
    m_songTitleLabel = new QLabel("未选择歌曲", this);
    m_songTitleLabel->setStyleSheet("font-size: 18px; font-weight: bold;");
    m_songTitleLabel->setAlignment(Qt::AlignCenter);
    
    m_songArtistLabel = new QLabel("", this);
    m_songArtistLabel->setStyleSheet("font-size: 12px; color: gray;");
    m_songArtistLabel->setAlignment(Qt::AlignCenter);
    
    infoLayout->addWidget(m_songTitleLabel);
    infoLayout->addWidget(m_songArtistLabel);
    mainLayout->addWidget(infoGroup);
    
    // 进度条区域
    QHBoxLayout* progressLayout = new QHBoxLayout();
    m_currentTimeLabel = new QLabel("00:00", this);
    m_progressSlider = new ClickableSlider(Qt::Horizontal, this);
    m_totalTimeLabel = new QLabel("00:00", this);
    
    connect(m_progressSlider, &ClickableSlider::sliderMoved,
            this, &MainWindow::onProgressSliderMoved);
    
    progressLayout->addWidget(m_currentTimeLabel);
    progressLayout->addWidget(m_progressSlider);
    progressLayout->addWidget(m_totalTimeLabel);
    mainLayout->addLayout(progressLayout);
    
    // 控制按钮区域
    QHBoxLayout* controlLayout = new QHBoxLayout();
    controlLayout->addStretch();
    
    m_previousBtn = new QPushButton(this);
    m_previousBtn->setIcon(style()->standardIcon(QStyle::SP_MediaSkipBackward));
    m_previousBtn->setIconSize(QSize(32, 32));
    m_previousBtn->setFixedSize(50, 50);
    connect(m_previousBtn, &QPushButton::clicked, 
            this, &MainWindow::onPreviousClicked);
    
    m_playPauseBtn = new QPushButton(this);
    m_playPauseBtn->setIcon(style()->standardIcon(QStyle::SP_MediaPlay));
    m_playPauseBtn->setIconSize(QSize(40, 40));
    m_playPauseBtn->setFixedSize(60, 60);
    connect(m_playPauseBtn, &QPushButton::clicked, 
            this, &MainWindow::onPlayPauseClicked);
    
    m_nextBtn = new QPushButton(this);
    m_nextBtn->setIcon(style()->standardIcon(QStyle::SP_MediaSkipForward));
    m_nextBtn->setIconSize(QSize(32, 32));
    m_nextBtn->setFixedSize(50, 50);
    connect(m_nextBtn, &QPushButton::clicked, 
            this, &MainWindow::onNextClicked);
    
    controlLayout->addWidget(m_previousBtn);
    controlLayout->addWidget(m_playPauseBtn);
    controlLayout->addWidget(m_nextBtn);
    controlLayout->addStretch();
    mainLayout->addLayout(controlLayout);
    
    // 音量控制
    QHBoxLayout* volumeLayout = new QHBoxLayout();
    volumeLayout->addStretch();
    QLabel* volumeLabel = new QLabel("音量:", this);
    m_volumeSlider = new ClickableSlider(Qt::Horizontal, this);
    m_volumeSlider->setRange(0, 100);
    m_volumeSlider->setValue(70);
    m_volumeSlider->setMaximumWidth(150);
    connect(m_volumeSlider, &ClickableSlider::valueChanged,
            this, &MainWindow::onVolumeChanged);
    
    volumeLayout->addWidget(volumeLabel);
    volumeLayout->addWidget(m_volumeSlider);
    volumeLayout->addStretch();
    mainLayout->addLayout(volumeLayout);
    
    // 播放列表管理区域
    QHBoxLayout* playlistControlLayout = new QHBoxLayout();
    
    QLabel* playlistLabel = new QLabel("播放列表:", this);
    m_playlistComboBox = new QComboBox(this);
    connect(m_playlistComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &MainWindow::onPlaylistChanged);
    
    m_addSongsBtn = new QPushButton("添加歌曲", this);
    connect(m_addSongsBtn, &QPushButton::clicked,
            this, &MainWindow::onAddSongsClicked);
    
    m_createPlaylistBtn = new QPushButton("新建列表", this);
    connect(m_createPlaylistBtn, &QPushButton::clicked,
            this, &MainWindow::onCreatePlaylistClicked);
    
    m_deletePlaylistBtn = new QPushButton("删除列表", this);
    connect(m_deletePlaylistBtn, &QPushButton::clicked,
            this, &MainWindow::onDeletePlaylistClicked);
    
    playlistControlLayout->addWidget(playlistLabel);
    playlistControlLayout->addWidget(m_playlistComboBox);
    playlistControlLayout->addWidget(m_addSongsBtn);
    playlistControlLayout->addWidget(m_createPlaylistBtn);
    playlistControlLayout->addWidget(m_deletePlaylistBtn);
    playlistControlLayout->addStretch();
    mainLayout->addLayout(playlistControlLayout);
    
    // 歌曲列表
    QGroupBox* songListGroup = new QGroupBox("歌曲列表", this);
    QVBoxLayout* songListLayout = new QVBoxLayout(songListGroup);
    
    m_songListWidget = new QListWidget(this);
    connect(m_songListWidget, &QListWidget::itemDoubleClicked,
            this, &MainWindow::onSongDoubleClicked);
    
    songListLayout->addWidget(m_songListWidget);
    mainLayout->addWidget(songListGroup);
    
    // 设置初始音量
    m_audioOutput->setVolume(0.7);
}

void MainWindow::updatePlaylistView() {
    m_playlistComboBox->clear();
    for (const Playlist* pl : m_playlistManager->getPlaylists()) {
        m_playlistComboBox->addItem(
            QString("%1 (%2)").arg(pl->getName()).arg(pl->songCount())
        );
    }
    m_playlistComboBox->setCurrentIndex(m_currentPlaylistIndex);
}

void MainWindow::updateSongListView() {
    m_songListWidget->clear();
    
    Playlist* playlist = m_playlistManager->getPlaylist(m_currentPlaylistIndex);
    if (!playlist) return;
    
    int index = 0;
    for (const Song& song : playlist->getSongs()) {
        QString itemText = QString("%1. %2 - %3")
            .arg(index + 1)
            .arg(song.title)
            .arg(song.artist);
        
        QListWidgetItem* item = new QListWidgetItem(itemText);
        item->setData(Qt::UserRole, index);
        
        if (index == m_currentSongIndex) {
            item->setBackground(QColor(100, 150, 255, 50));
        }
        
        m_songListWidget->addItem(item);
        index++;
    }
}

void MainWindow::playSong(int index) {
    Playlist* playlist = m_playlistManager->getPlaylist(m_currentPlaylistIndex);
    if (!playlist || index < 0 || index >= playlist->songCount()) {
        return;
    }
    
    Song song = playlist->getSong(index);
    m_currentSongIndex = index;
    
    m_player->setSource(QUrl::fromLocalFile(song.filePath));
    m_player->play();
    
    m_songTitleLabel->setText(song.title);
    m_songArtistLabel->setText(song.artist);
    
    updateSongListView();
    updatePlayPauseButton();
}

void MainWindow::updatePlayPauseButton() {
    if (m_player->playbackState() == QMediaPlayer::PlayingState) {
        m_playPauseBtn->setIcon(style()->standardIcon(QStyle::SP_MediaPause));
    } else {
        m_playPauseBtn->setIcon(style()->standardIcon(QStyle::SP_MediaPlay));
    }
}

QString MainWindow::formatTime(qint64 milliseconds) {
    int seconds = milliseconds / 1000;
    int minutes = seconds / 60;
    seconds = seconds % 60;
    return QString("%1:%2")
        .arg(minutes, 2, 10, QChar('0'))
        .arg(seconds, 2, 10, QChar('0'));
}

void MainWindow::onPlayPauseClicked() {
    if (m_currentSongIndex < 0) {
        playSong(0);
        return;
    }
    
    if (m_player->playbackState() == QMediaPlayer::PlayingState) {
        m_player->pause();
    } else {
        m_player->play();
    }
    updatePlayPauseButton();
}

void MainWindow::onPreviousClicked() {
    if (m_currentSongIndex > 0) {
        playSong(m_currentSongIndex - 1);
    }
}

void MainWindow::onNextClicked() {
    Playlist* playlist = m_playlistManager->getPlaylist(m_currentPlaylistIndex);
    if (playlist && m_currentSongIndex < playlist->songCount() - 1) {
        playSong(m_currentSongIndex + 1);
    }
}

void MainWindow::onAddSongsClicked() {
    QStringList files = QFileDialog::getOpenFileNames(
        this,
        "选择音乐文件",
        QDir::homePath(),
        "音频文件 (*.mp3 *.wav *.ogg *.flac *.m4a);;所有文件 (*.*)"
    );
    
    if (files.isEmpty()) return;
    
    Playlist* playlist = m_playlistManager->getPlaylist(m_currentPlaylistIndex);
    if (!playlist) return;
    
    for (const QString& file : files) {
        // 确保文件路径使用正确的编码
        QString normalizedPath = QDir::toNativeSeparators(file);
        playlist->addSong(Song(normalizedPath));
    }
    
    updatePlaylistView();
    updateSongListView();
}

void MainWindow::onCreatePlaylistClicked() {
    bool ok;
    QString name = QInputDialog::getText(
        this,
        "新建播放列表",
        "请输入播放列表名称:",
        QLineEdit::Normal,
        "新建列表",
        &ok
    );
    
    if (ok && !name.isEmpty()) {
        m_playlistManager->addPlaylist(name);
        updatePlaylistView();
    }
}

void MainWindow::onDeletePlaylistClicked() {
    if (m_playlistManager->playlistCount() <= 1) {
        QMessageBox::warning(this, "警告", "至少需要保留一个播放列表！");
        return;
    }
    
    m_playlistManager->removePlaylist(m_currentPlaylistIndex);
    m_currentPlaylistIndex = 0;
    m_currentSongIndex = -1;
    updatePlaylistView();
    updateSongListView();
}

void MainWindow::onPlaylistChanged(int index) {
    m_currentPlaylistIndex = index;
    m_currentSongIndex = -1;
    updateSongListView();
}

void MainWindow::onSongDoubleClicked(QListWidgetItem* item) {
    int index = item->data(Qt::UserRole).toInt();
    playSong(index);
}

void MainWindow::onPositionChanged(qint64 position) {
    m_progressSlider->setValue(position);
    m_currentTimeLabel->setText(formatTime(position));
}

void MainWindow::onDurationChanged(qint64 duration) {
    m_progressSlider->setRange(0, duration);
    m_totalTimeLabel->setText(formatTime(duration));
}

void MainWindow::onProgressSliderMoved(int position) {
    m_player->setPosition(position);
}

void MainWindow::onVolumeChanged(int value) {
    m_audioOutput->setVolume(value / 100.0);
}

void MainWindow::onMediaStatusChanged(QMediaPlayer::MediaStatus status) {
    if (status == QMediaPlayer::EndOfMedia) {
        onNextClicked();
    }
    updatePlayPauseButton();
}

// ============================================================================
// main.cpp - 程序入口
// ============================================================================
#include <QApplication>
#include <QTextCodec>     // 重新包含头文件
#include "mainwindow.h"

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    
    // 恢复这部分代码，这对于处理来自系统API的本地编码至关重要
    #ifdef Q_OS_WIN
    QTextCodec::setCodecForLocale(QTextCodec::codecForName("GBK"));
    #endif
    
    MainWindow window;
    window.show();
    
    return app.exec();
}